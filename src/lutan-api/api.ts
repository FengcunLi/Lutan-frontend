/* tslint:disable */
/* eslint-disable */
/**
 * Lutan API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Activation
 */
export interface Activation {
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    uid: string;
    /**
     * 
     * @type {string}
     * @memberof Activation
     */
    token: string;
}
/**
 * 
 * @export
 * @interface Avatar
 */
export interface Avatar {
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    height?: number;
    /**
     * 
     * @type {string}
     * @memberof Avatar
     */
    image?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Avatar
     */
    original?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Avatar
     */
    user?: number;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    parent: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    is_closed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    lft?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    rght?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    is_leaf_node?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    is_child_node?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    is_root_node?: string;
}
/**
 * 
 * @export
 * @interface CategorySimple
 */
export interface CategorySimple {
    /**
     * 
     * @type {number}
     * @memberof CategorySimple
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategorySimple
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CategoryTree
 */
export interface CategoryTree {
    /**
     * 
     * @type {number}
     * @memberof CategoryTree
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryTree
     */
    parent?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryTree
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryTree
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CategoryTree
     */
    is_closed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CategoryTree
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryTree
     */
    lft?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryTree
     */
    rght?: number;
    /**
     * 
     * @type {Array<CategoryTree>}
     * @memberof CategoryTree
     */
    subcategories?: Array<CategoryTree>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserProxy>}
     * @memberof InlineResponse200
     */
    results: Array<UserProxy>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ThreadListModel>}
     * @memberof InlineResponse2001
     */
    results: Array<ThreadListModel>;
}
/**
 * 
 * @export
 * @interface PasswordResetConfirm
 */
export interface PasswordResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    uid: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirm
     */
    new_password: string;
}
/**
 * 
 * @export
 * @interface PostLike
 */
export interface PostLike {
    /**
     * 
     * @type {number}
     * @memberof PostLike
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PostLike
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof PostLike
     */
    post?: number;
    /**
     * 
     * @type {number}
     * @memberof PostLike
     */
    liker?: number;
}
/**
 * 
 * @export
 * @interface PostReadOnly
 */
export interface PostReadOnly {
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    id?: number;
    /**
     * 
     * @type {Poster}
     * @memberof PostReadOnly
     */
    poster: Poster;
    /**
     * 
     * @type {Array<PostReadOnly>}
     * @memberof PostReadOnly
     */
    children?: Array<PostReadOnly>;
    /**
     * 
     * @type {Array<PostLike>}
     * @memberof PostReadOnly
     */
    post_likes?: Array<PostLike>;
    /**
     * 
     * @type {boolean}
     * @memberof PostReadOnly
     */
    can_like_this_post?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostReadOnly
     */
    liked_by_current_user?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostReadOnly
     */
    content: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostReadOnly
     */
    is_unapproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostReadOnly
     */
    is_hidden?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostReadOnly
     */
    created_on?: string;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    lft?: number;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    rght?: number;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    tree_id?: number;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    parent?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PostReadOnly
     */
    thread: number;
}
/**
 * 
 * @export
 * @interface PostWritable
 */
export interface PostWritable {
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PostWritable
     */
    content: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostWritable
     */
    is_unapproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostWritable
     */
    is_hidden?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostWritable
     */
    created_on?: string;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    lft?: number;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    rght?: number;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    tree_id?: number;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    level?: number;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    parent?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    thread: number;
    /**
     * 
     * @type {number}
     * @memberof PostWritable
     */
    poster?: number | null;
}
/**
 * 
 * @export
 * @interface Poster
 */
export interface Poster {
    /**
     * 
     * @type {number}
     * @memberof Poster
     */
    id?: number;
    /**
     * 
     * @type {Array<Avatar>}
     * @memberof Poster
     */
    avatars?: Array<Avatar>;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    last_login?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof Poster
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    email: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof Poster
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof Poster
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    date_joined?: string;
    /**
     * 
     * @type {string}
     * @memberof Poster
     */
    signature?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Set<number>}
     * @memberof Poster
     */
    groups?: Set<number>;
    /**
     * Specific permissions for this user.
     * @type {Set<number>}
     * @memberof Poster
     */
    user_permissions?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof Poster
     */
    followings: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof Poster
     */
    blockings: Set<number>;
}
/**
 * 
 * @export
 * @interface SendEmailReset
 */
export interface SendEmailReset {
    /**
     * 
     * @type {string}
     * @memberof SendEmailReset
     */
    email: string;
}
/**
 * 
 * @export
 * @interface SetPassword
 */
export interface SetPassword {
    /**
     * 
     * @type {string}
     * @memberof SetPassword
     */
    new_password: string;
    /**
     * 
     * @type {string}
     * @memberof SetPassword
     */
    current_password: string;
}
/**
 * 
 * @export
 * @interface SetUsername
 */
export interface SetUsername {
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    current_password: string;
    /**
     * 
     * @type {string}
     * @memberof SetUsername
     */
    new_email: string;
}
/**
 * 
 * @export
 * @interface Starter
 */
export interface Starter {
    /**
     * 
     * @type {number}
     * @memberof Starter
     */
    id?: number;
    /**
     * 
     * @type {Array<Avatar>}
     * @memberof Starter
     */
    avatars?: Array<Avatar>;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    last_login?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof Starter
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    email: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof Starter
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof Starter
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    date_joined?: string;
    /**
     * 
     * @type {string}
     * @memberof Starter
     */
    signature?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Set<number>}
     * @memberof Starter
     */
    groups?: Set<number>;
    /**
     * Specific permissions for this user.
     * @type {Set<number>}
     * @memberof Starter
     */
    user_permissions?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof Starter
     */
    followings: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof Starter
     */
    blockings: Set<number>;
}
/**
 * 
 * @export
 * @interface ThreadListModel
 */
export interface ThreadListModel {
    /**
     * 
     * @type {number}
     * @memberof ThreadListModel
     */
    id?: number;
    /**
     * 
     * @type {Starter}
     * @memberof ThreadListModel
     */
    starter?: Starter;
    /**
     * 
     * @type {Set<number>}
     * @memberof ThreadListModel
     */
    posts?: Set<number>;
    /**
     * 
     * @type {CategorySimple}
     * @memberof ThreadListModel
     */
    category: CategorySimple;
    /**
     * 
     * @type {string}
     * @memberof ThreadListModel
     */
    last_activity?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadListModel
     */
    can_delete_this_thread?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadListModel
     */
    can_change_this_thread?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadListModel
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof ThreadListModel
     */
    weight?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadListModel
     */
    is_unapproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadListModel
     */
    is_hidden?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadListModel
     */
    is_closed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadListModel
     */
    created_on?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadListModel
     */
    last_post_created_on?: string | null;
}
/**
 * 
 * @export
 * @interface ThreadRead
 */
export interface ThreadRead {
    /**
     * 
     * @type {number}
     * @memberof ThreadRead
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ThreadRead
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof ThreadRead
     */
    reader: number;
    /**
     * 
     * @type {number}
     * @memberof ThreadRead
     */
    thread: number;
}
/**
 * 
 * @export
 * @interface ThreadRetrieveModel
 */
export interface ThreadRetrieveModel {
    /**
     * 
     * @type {number}
     * @memberof ThreadRetrieveModel
     */
    id?: number;
    /**
     * 
     * @type {Starter}
     * @memberof ThreadRetrieveModel
     */
    starter?: Starter;
    /**
     * 
     * @type {Array<PostReadOnly>}
     * @memberof ThreadRetrieveModel
     */
    posts?: Array<PostReadOnly>;
    /**
     * 
     * @type {CategorySimple}
     * @memberof ThreadRetrieveModel
     */
    category: CategorySimple;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadRetrieveModel
     */
    can_delete_this_thread?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadRetrieveModel
     */
    can_change_this_thread?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadRetrieveModel
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadRetrieveModel
     */
    content?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadRetrieveModel
     */
    weight?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadRetrieveModel
     */
    is_unapproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadRetrieveModel
     */
    is_hidden?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadRetrieveModel
     */
    is_closed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadRetrieveModel
     */
    created_on?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadRetrieveModel
     */
    last_post_created_on?: string | null;
}
/**
 * 
 * @export
 * @interface ThreadSubscription
 */
export interface ThreadSubscription {
    /**
     * 
     * @type {number}
     * @memberof ThreadSubscription
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ThreadSubscription
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof ThreadSubscription
     */
    subscriber: number;
    /**
     * 
     * @type {number}
     * @memberof ThreadSubscription
     */
    thread: number;
}
/**
 * 
 * @export
 * @interface ThreadWritable
 */
export interface ThreadWritable {
    /**
     * 
     * @type {number}
     * @memberof ThreadWritable
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ThreadWritable
     */
    starter: number;
    /**
     * 
     * @type {string}
     * @memberof ThreadWritable
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadWritable
     */
    content?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadWritable
     */
    weight?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadWritable
     */
    is_unapproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadWritable
     */
    is_hidden?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadWritable
     */
    is_closed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadWritable
     */
    created_on?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadWritable
     */
    last_post_created_on?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ThreadWritable
     */
    category: number;
}
/**
 * 
 * @export
 * @interface TokenCreate
 */
export interface TokenCreate {
    /**
     * 
     * @type {string}
     * @memberof TokenCreate
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenCreate
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    password: string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    refresh: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    token: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserProxy
 */
export interface UserProxy {
    /**
     * 
     * @type {number}
     * @memberof UserProxy
     */
    id?: number;
    /**
     * 
     * @type {Array<Avatar>}
     * @memberof UserProxy
     */
    avatars?: Array<Avatar>;
    /**
     * 
     * @type {Set<number>}
     * @memberof UserProxy
     */
    posts?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof UserProxy
     */
    threads?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof UserProxy
     */
    followers?: Set<number>;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    last_login?: string | null;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof UserProxy
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    email?: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof UserProxy
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof UserProxy
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    date_joined?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProxy
     */
    signature?: string | null;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Set<number>}
     * @memberof UserProxy
     */
    groups?: Set<number>;
    /**
     * Specific permissions for this user.
     * @type {Set<number>}
     * @memberof UserProxy
     */
    user_permissions?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof UserProxy
     */
    followings: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof UserProxy
     */
    blockings: Set<number>;
}
/**
 * 
 * @export
 * @interface UsernameResetConfirm
 */
export interface UsernameResetConfirm {
    /**
     * 
     * @type {string}
     * @memberof UsernameResetConfirm
     */
    new_email: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtCreateCreate: async (data: TokenObtainPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authJwtCreateCreate.');
            }
            const localVarPath = `/auth/jwt/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtRefreshCreate: async (data: TokenRefresh, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authJwtRefreshCreate.');
            }
            const localVarPath = `/auth/jwt/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtVerifyCreate: async (data: TokenVerify, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authJwtVerifyCreate.');
            }
            const localVarPath = `/auth/jwt/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLoginCreate: async (data: TokenCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authTokenLoginCreate.');
            }
            const localVarPath = `/auth/token/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLogoutCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersActivation: async (data: Activation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersActivation.');
            }
            const localVarPath = `/auth/users/activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersCreate: async (data: UserCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersCreate.');
            }
            const localVarPath = `/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling authUsersDelete.');
            }
            const localVarPath = `/auth/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersList: async (name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (followingUser !== undefined) {
                localVarQueryParameter['following_user'] = followingUser;
            }

            if (followedByUser !== undefined) {
                localVarQueryParameter['followed_by_user'] = followedByUser;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMePartialUpdate: async (data: UserProxy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersMePartialUpdate.');
            }
            const localVarPath = `/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeRead: async (name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (followingUser !== undefined) {
                localVarQueryParameter['following_user'] = followingUser;
            }

            if (followedByUser !== undefined) {
                localVarQueryParameter['followed_by_user'] = followedByUser;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeUpdate: async (data: UserProxy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersMeUpdate.');
            }
            const localVarPath = `/auth/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersPartialUpdate: async (id: number, data: UserProxy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling authUsersPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersPartialUpdate.');
            }
            const localVarPath = `/auth/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling authUsersRead.');
            }
            const localVarPath = `/auth/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResendActivation: async (data: SendEmailReset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersResendActivation.');
            }
            const localVarPath = `/auth/users/resend_activation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetPassword: async (data: SendEmailReset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersResetPassword.');
            }
            const localVarPath = `/auth/users/reset_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetPasswordConfirm: async (data: PasswordResetConfirm, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersResetPasswordConfirm.');
            }
            const localVarPath = `/auth/users/reset_password_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetUsername: async (data: SendEmailReset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersResetUsername.');
            }
            const localVarPath = `/auth/users/reset_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetUsernameConfirm: async (data: UsernameResetConfirm, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersResetUsernameConfirm.');
            }
            const localVarPath = `/auth/users/reset_email_confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersSetPassword: async (data: SetPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersSetPassword.');
            }
            const localVarPath = `/auth/users/set_password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersSetUsername: async (data: SetUsername, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersSetUsername.');
            }
            const localVarPath = `/auth/users/set_email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersUpdate: async (id: number, data: UserProxy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling authUsersUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling authUsersUpdate.');
            }
            const localVarPath = `/auth/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtCreateCreate(data: TokenObtainPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authJwtCreateCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtRefreshCreate(data: TokenRefresh, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authJwtRefreshCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtVerifyCreate(data: TokenVerify, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authJwtVerifyCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenLoginCreate(data: TokenCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreate>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authTokenLoginCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenLogoutCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authTokenLogoutCreate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersActivation(data: Activation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activation>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersActivation(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersCreate(data: UserCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreate>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersList(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersList(name, followingUser, followedByUser, ordering, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersMeDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersMeDelete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersMePartialUpdate(data: UserProxy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProxy>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersMePartialUpdate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersMeRead(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersMeRead(name, followingUser, followedByUser, ordering, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersMeUpdate(data: UserProxy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProxy>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersMeUpdate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersPartialUpdate(id: number, data: UserProxy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProxy>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersPartialUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProxy>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersResendActivation(data: SendEmailReset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersResendActivation(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersResetPassword(data: SendEmailReset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersResetPassword(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetConfirm>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersResetPasswordConfirm(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersResetUsername(data: SendEmailReset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersResetUsername(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsernameResetConfirm>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersResetUsernameConfirm(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SetPassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersSetPassword(data: SetPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetPassword>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersSetPassword(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersSetUsername(data: SetUsername, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUsername>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersSetUsername(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authUsersUpdate(id: number, data: UserProxy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProxy>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).authUsersUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtCreateCreate(data: TokenObtainPair, options?: any): AxiosPromise<TokenObtainPair> {
            return AuthApiFp(configuration).authJwtCreateCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtRefreshCreate(data: TokenRefresh, options?: any): AxiosPromise<TokenRefresh> {
            return AuthApiFp(configuration).authJwtRefreshCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtVerifyCreate(data: TokenVerify, options?: any): AxiosPromise<TokenVerify> {
            return AuthApiFp(configuration).authJwtVerifyCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to obtain user authentication token.
         * @param {TokenCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLoginCreate(data: TokenCreate, options?: any): AxiosPromise<TokenCreate> {
            return AuthApiFp(configuration).authTokenLoginCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to logout user (remove user authentication token).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenLogoutCreate(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authTokenLogoutCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Activation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersActivation(data: Activation, options?: any): AxiosPromise<Activation> {
            return AuthApiFp(configuration).authUsersActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersCreate(data: UserCreate, options?: any): AxiosPromise<UserCreate> {
            return AuthApiFp(configuration).authUsersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersDelete(id: number, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authUsersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersList(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse200> {
            return AuthApiFp(configuration).authUsersList(name, followingUser, followedByUser, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeDelete(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).authUsersMeDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMePartialUpdate(data: UserProxy, options?: any): AxiosPromise<UserProxy> {
            return AuthApiFp(configuration).authUsersMePartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [followingUser] 
         * @param {number} [followedByUser] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeRead(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse200> {
            return AuthApiFp(configuration).authUsersMeRead(name, followingUser, followedByUser, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersMeUpdate(data: UserProxy, options?: any): AxiosPromise<UserProxy> {
            return AuthApiFp(configuration).authUsersMeUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersPartialUpdate(id: number, data: UserProxy, options?: any): AxiosPromise<UserProxy> {
            return AuthApiFp(configuration).authUsersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersRead(id: number, options?: any): AxiosPromise<UserProxy> {
            return AuthApiFp(configuration).authUsersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResendActivation(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return AuthApiFp(configuration).authUsersResendActivation(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetPassword(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return AuthApiFp(configuration).authUsersResetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: any): AxiosPromise<PasswordResetConfirm> {
            return AuthApiFp(configuration).authUsersResetPasswordConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailReset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetUsername(data: SendEmailReset, options?: any): AxiosPromise<SendEmailReset> {
            return AuthApiFp(configuration).authUsersResetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsernameResetConfirm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: any): AxiosPromise<UsernameResetConfirm> {
            return AuthApiFp(configuration).authUsersResetUsernameConfirm(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPassword} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersSetPassword(data: SetPassword, options?: any): AxiosPromise<SetPassword> {
            return AuthApiFp(configuration).authUsersSetPassword(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUsername} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersSetUsername(data: SetUsername, options?: any): AxiosPromise<SetUsername> {
            return AuthApiFp(configuration).authUsersSetUsername(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {UserProxy} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authUsersUpdate(id: number, data: UserProxy, options?: any): AxiosPromise<UserProxy> {
            return AuthApiFp(configuration).authUsersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtCreateCreate(data: TokenObtainPair, options?: any) {
        return AuthApiFp(this.configuration).authJwtCreateCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtRefreshCreate(data: TokenRefresh, options?: any) {
        return AuthApiFp(this.configuration).authJwtRefreshCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtVerifyCreate(data: TokenVerify, options?: any) {
        return AuthApiFp(this.configuration).authJwtVerifyCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to obtain user authentication token.
     * @param {TokenCreate} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenLoginCreate(data: TokenCreate, options?: any) {
        return AuthApiFp(this.configuration).authTokenLoginCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to logout user (remove user authentication token).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenLogoutCreate(options?: any) {
        return AuthApiFp(this.configuration).authTokenLogoutCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Activation} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersActivation(data: Activation, options?: any) {
        return AuthApiFp(this.configuration).authUsersActivation(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreate} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersCreate(data: UserCreate, options?: any) {
        return AuthApiFp(this.configuration).authUsersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersDelete(id: number, options?: any) {
        return AuthApiFp(this.configuration).authUsersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {number} [followingUser] 
     * @param {number} [followedByUser] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersList(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any) {
        return AuthApiFp(this.configuration).authUsersList(name, followingUser, followedByUser, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersMeDelete(options?: any) {
        return AuthApiFp(this.configuration).authUsersMeDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserProxy} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersMePartialUpdate(data: UserProxy, options?: any) {
        return AuthApiFp(this.configuration).authUsersMePartialUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {number} [followingUser] 
     * @param {number} [followedByUser] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersMeRead(name?: string, followingUser?: number, followedByUser?: number, ordering?: string, page?: number, pageSize?: number, options?: any) {
        return AuthApiFp(this.configuration).authUsersMeRead(name, followingUser, followedByUser, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserProxy} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersMeUpdate(data: UserProxy, options?: any) {
        return AuthApiFp(this.configuration).authUsersMeUpdate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {UserProxy} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersPartialUpdate(id: number, data: UserProxy, options?: any) {
        return AuthApiFp(this.configuration).authUsersPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersRead(id: number, options?: any) {
        return AuthApiFp(this.configuration).authUsersRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersResendActivation(data: SendEmailReset, options?: any) {
        return AuthApiFp(this.configuration).authUsersResendActivation(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersResetPassword(data: SendEmailReset, options?: any) {
        return AuthApiFp(this.configuration).authUsersResetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetConfirm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersResetPasswordConfirm(data: PasswordResetConfirm, options?: any) {
        return AuthApiFp(this.configuration).authUsersResetPasswordConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailReset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersResetUsername(data: SendEmailReset, options?: any) {
        return AuthApiFp(this.configuration).authUsersResetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsernameResetConfirm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersResetUsernameConfirm(data: UsernameResetConfirm, options?: any) {
        return AuthApiFp(this.configuration).authUsersResetUsernameConfirm(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPassword} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersSetPassword(data: SetPassword, options?: any) {
        return AuthApiFp(this.configuration).authUsersSetPassword(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUsername} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersSetUsername(data: SetUsername, options?: any) {
        return AuthApiFp(this.configuration).authUsersSetUsername(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {UserProxy} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authUsersUpdate(id: number, data: UserProxy, options?: any) {
        return AuthApiFp(this.configuration).authUsersUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AvatarsApi - axios parameter creator
 * @export
 */
export const AvatarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsCreate: async (data: Avatar, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling avatarsCreate.');
            }
            const localVarPath = `/avatars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling avatarsDelete.');
            }
            const localVarPath = `/avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/avatars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsPartialUpdate: async (id: number, data: Avatar, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling avatarsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling avatarsPartialUpdate.');
            }
            const localVarPath = `/avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling avatarsRead.');
            }
            const localVarPath = `/avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsUpdate: async (id: number, data: Avatar, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling avatarsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling avatarsUpdate.');
            }
            const localVarPath = `/avatars/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvatarsApi - functional programming interface
 * @export
 */
export const AvatarsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsCreate(data: Avatar, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsPartialUpdate(id: number, data: Avatar, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsPartialUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsUpdate(id: number, data: Avatar, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>> {
            const localVarAxiosArgs = await AvatarsApiAxiosParamCreator(configuration).avatarsUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AvatarsApi - factory interface
 * @export
 */
export const AvatarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsCreate(data: Avatar, options?: any): AxiosPromise<Avatar> {
            return AvatarsApiFp(configuration).avatarsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsDelete(id: number, options?: any): AxiosPromise<void> {
            return AvatarsApiFp(configuration).avatarsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsList(options?: any): AxiosPromise<Array<Avatar>> {
            return AvatarsApiFp(configuration).avatarsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsPartialUpdate(id: number, data: Avatar, options?: any): AxiosPromise<Avatar> {
            return AvatarsApiFp(configuration).avatarsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsRead(id: number, options?: any): AxiosPromise<Avatar> {
            return AvatarsApiFp(configuration).avatarsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this avatar.
         * @param {Avatar} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsUpdate(id: number, data: Avatar, options?: any): AxiosPromise<Avatar> {
            return AvatarsApiFp(configuration).avatarsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvatarsApi - object-oriented interface
 * @export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
export class AvatarsApi extends BaseAPI {
    /**
     * 
     * @param {Avatar} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsCreate(data: Avatar, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this avatar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsDelete(id: number, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsList(options?: any) {
        return AvatarsApiFp(this.configuration).avatarsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this avatar.
     * @param {Avatar} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsPartialUpdate(id: number, data: Avatar, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this avatar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsRead(id: number, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this avatar.
     * @param {Avatar} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsUpdate(id: number, data: Avatar, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate: async (data: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling categoriesCreate.');
            }
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriesDelete.');
            }
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate: async (id: number, data: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling categoriesPartialUpdate.');
            }
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriesRead.');
            }
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesTreeRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriesTreeRead.');
            }
            const localVarPath = `/categories/tree/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate: async (id: number, data: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling categoriesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling categoriesUpdate.');
            }
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesCreate(data: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesPartialUpdate(id: number, data: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesPartialUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesTreeRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryTree>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesTreeRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesUpdate(id: number, data: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).categoriesUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate(data: Category, options?: any): AxiosPromise<Category> {
            return CategoriesApiFp(configuration).categoriesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete(id: number, options?: any): AxiosPromise<void> {
            return CategoriesApiFp(configuration).categoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList(options?: any): AxiosPromise<Array<Category>> {
            return CategoriesApiFp(configuration).categoriesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return CategoriesApiFp(configuration).categoriesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead(id: number, options?: any): AxiosPromise<Category> {
            return CategoriesApiFp(configuration).categoriesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesTreeRead(id: number, options?: any): AxiosPromise<CategoryTree> {
            return CategoriesApiFp(configuration).categoriesTreeRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return CategoriesApiFp(configuration).categoriesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesCreate(data: Category, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesDelete(id: number, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesList(options?: any) {
        return CategoriesApiFp(this.configuration).categoriesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesPartialUpdate(id: number, data: Category, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesRead(id: number, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesTreeRead(id: number, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesTreeRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesUpdate(id: number, data: Category, options?: any) {
        return CategoriesApiFp(this.configuration).categoriesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsCancelLike: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsCancelLike.');
            }
            const localVarPath = `/posts/{id}/cancel_like/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsCreate: async (data: PostWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling postsCreate.');
            }
            const localVarPath = `/posts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsDelete.');
            }
            const localVarPath = `/posts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostLike} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsLike: async (id: number, data: PostLike, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsLike.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling postsLike.');
            }
            const localVarPath = `/posts/{id}/like/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsPartialUpdate: async (id: number, data: PostWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling postsPartialUpdate.');
            }
            const localVarPath = `/posts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsRead.');
            }
            const localVarPath = `/posts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsUpdate: async (id: number, data: PostWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling postsUpdate.');
            }
            const localVarPath = `/posts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsCancelLike(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsCancelLike(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsCreate(data: PostWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWritable>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostLike} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsLike(id: number, data: PostLike, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostLike>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsLike(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostReadOnly>>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsPartialUpdate(id: number, data: PostWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWritable>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsPartialUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostReadOnly>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postsUpdate(id: number, data: PostWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWritable>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).postsUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsCancelLike(id: number, options?: any): AxiosPromise<void> {
            return PostsApiFp(configuration).postsCancelLike(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsCreate(data: PostWritable, options?: any): AxiosPromise<PostWritable> {
            return PostsApiFp(configuration).postsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsDelete(id: number, options?: any): AxiosPromise<void> {
            return PostsApiFp(configuration).postsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostLike} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsLike(id: number, data: PostLike, options?: any): AxiosPromise<PostLike> {
            return PostsApiFp(configuration).postsLike(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsList(options?: any): AxiosPromise<Array<PostReadOnly>> {
            return PostsApiFp(configuration).postsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsPartialUpdate(id: number, data: PostWritable, options?: any): AxiosPromise<PostWritable> {
            return PostsApiFp(configuration).postsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsRead(id: number, options?: any): AxiosPromise<PostReadOnly> {
            return PostsApiFp(configuration).postsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this post.
         * @param {PostWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsUpdate(id: number, data: PostWritable, options?: any): AxiosPromise<PostWritable> {
            return PostsApiFp(configuration).postsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsCancelLike(id: number, options?: any) {
        return PostsApiFp(this.configuration).postsCancelLike(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsCreate(data: PostWritable, options?: any) {
        return PostsApiFp(this.configuration).postsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsDelete(id: number, options?: any) {
        return PostsApiFp(this.configuration).postsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {PostLike} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsLike(id: number, data: PostLike, options?: any) {
        return PostsApiFp(this.configuration).postsLike(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsList(options?: any) {
        return PostsApiFp(this.configuration).postsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {PostWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsPartialUpdate(id: number, data: PostWritable, options?: any) {
        return PostsApiFp(this.configuration).postsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsRead(id: number, options?: any) {
        return PostsApiFp(this.configuration).postsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this post.
     * @param {PostWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsUpdate(id: number, data: PostWritable, options?: any) {
        return PostsApiFp(this.configuration).postsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThreadReadApi - axios parameter creator
 * @export
 */
export const ThreadReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadRead} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadReadCreate: async (data: ThreadRead, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling threadReadCreate.');
            }
            const localVarPath = `/thread-read/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadReadDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadReadDelete.');
            }
            const localVarPath = `/thread-read/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadReadApi - functional programming interface
 * @export
 */
export const ThreadReadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadRead} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadReadCreate(data: ThreadRead, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadRead>> {
            const localVarAxiosArgs = await ThreadReadApiAxiosParamCreator(configuration).threadReadCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadReadDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ThreadReadApiAxiosParamCreator(configuration).threadReadDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ThreadReadApi - factory interface
 * @export
 */
export const ThreadReadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ThreadRead} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadReadCreate(data: ThreadRead, options?: any): AxiosPromise<ThreadRead> {
            return ThreadReadApiFp(configuration).threadReadCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadReadDelete(id: number, options?: any): AxiosPromise<void> {
            return ThreadReadApiFp(configuration).threadReadDelete(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadReadApi - object-oriented interface
 * @export
 * @class ThreadReadApi
 * @extends {BaseAPI}
 */
export class ThreadReadApi extends BaseAPI {
    /**
     * 
     * @param {ThreadRead} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadReadApi
     */
    public threadReadCreate(data: ThreadRead, options?: any) {
        return ThreadReadApiFp(this.configuration).threadReadCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this thread read.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadReadApi
     */
    public threadReadDelete(id: number, options?: any) {
        return ThreadReadApiFp(this.configuration).threadReadDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThreadSubscriptionApi - axios parameter creator
 * @export
 */
export const ThreadSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadSubscription} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSubscriptionCreate: async (data: ThreadSubscription, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling threadSubscriptionCreate.');
            }
            const localVarPath = `/thread-subscription/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSubscriptionDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadSubscriptionDelete.');
            }
            const localVarPath = `/thread-subscription/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadSubscriptionApi - functional programming interface
 * @export
 */
export const ThreadSubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadSubscription} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadSubscriptionCreate(data: ThreadSubscription, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadSubscription>> {
            const localVarAxiosArgs = await ThreadSubscriptionApiAxiosParamCreator(configuration).threadSubscriptionCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadSubscriptionDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ThreadSubscriptionApiAxiosParamCreator(configuration).threadSubscriptionDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ThreadSubscriptionApi - factory interface
 * @export
 */
export const ThreadSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ThreadSubscription} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSubscriptionCreate(data: ThreadSubscription, options?: any): AxiosPromise<ThreadSubscription> {
            return ThreadSubscriptionApiFp(configuration).threadSubscriptionCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this thread subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadSubscriptionDelete(id: number, options?: any): AxiosPromise<void> {
            return ThreadSubscriptionApiFp(configuration).threadSubscriptionDelete(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadSubscriptionApi - object-oriented interface
 * @export
 * @class ThreadSubscriptionApi
 * @extends {BaseAPI}
 */
export class ThreadSubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {ThreadSubscription} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadSubscriptionApi
     */
    public threadSubscriptionCreate(data: ThreadSubscription, options?: any) {
        return ThreadSubscriptionApiFp(this.configuration).threadSubscriptionCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this thread subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadSubscriptionApi
     */
    public threadSubscriptionDelete(id: number, options?: any) {
        return ThreadSubscriptionApiFp(this.configuration).threadSubscriptionDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsCreate: async (data: ThreadWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling threadsCreate.');
            }
            const localVarPath = `/threads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadsDelete.');
            }
            const localVarPath = `/threads/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsHasNewPosts: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/has-new-posts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsList: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsMy: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/my/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsNew: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/new/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsPartialUpdate: async (id: string, data: ThreadWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling threadsPartialUpdate.');
            }
            const localVarPath = `/threads/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsRead: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadsRead.');
            }
            const localVarPath = `/threads/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsSubscribed: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/subscribed/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsUnapproved: async (title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads/unapproved/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (starter !== undefined) {
                localVarQueryParameter['starter'] = starter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsUpdate: async (id: string, data: ThreadWritable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling threadsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling threadsUpdate.');
            }
            const localVarPath = `/threads/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsCreate(data: ThreadWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadWritable>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsHasNewPosts(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsHasNewPosts(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsList(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsList(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsMy(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsMy(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsNew(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsNew(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsPartialUpdate(id: string, data: ThreadWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadWritable>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsPartialUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsRead(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadRetrieveModel>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsSubscribed(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsSubscribed(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsUnapproved(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsUnapproved(title, categories, starter, page, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async threadsUpdate(id: string, data: ThreadWritable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadWritable>> {
            const localVarAxiosArgs = await ThreadsApiAxiosParamCreator(configuration).threadsUpdate(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsCreate(data: ThreadWritable, options?: any): AxiosPromise<ThreadWritable> {
            return ThreadsApiFp(configuration).threadsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsDelete(id: string, options?: any): AxiosPromise<void> {
            return ThreadsApiFp(configuration).threadsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsHasNewPosts(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsHasNewPosts(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsList(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsList(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsMy(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsMy(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsNew(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsNew(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsPartialUpdate(id: string, data: ThreadWritable, options?: any): AxiosPromise<ThreadWritable> {
            return ThreadsApiFp(configuration).threadsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsRead(id: string, options?: any): AxiosPromise<ThreadRetrieveModel> {
            return ThreadsApiFp(configuration).threadsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsSubscribed(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsSubscribed(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {string} [categories] 
         * @param {string} [starter] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsUnapproved(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return ThreadsApiFp(configuration).threadsUnapproved(title, categories, starter, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ThreadWritable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        threadsUpdate(id: string, data: ThreadWritable, options?: any): AxiosPromise<ThreadWritable> {
            return ThreadsApiFp(configuration).threadsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
    /**
     * 
     * @param {ThreadWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsCreate(data: ThreadWritable, options?: any) {
        return ThreadsApiFp(this.configuration).threadsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsDelete(id: string, options?: any) {
        return ThreadsApiFp(this.configuration).threadsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsHasNewPosts(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsHasNewPosts(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsList(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsList(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsMy(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsMy(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsNew(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsNew(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ThreadWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsPartialUpdate(id: string, data: ThreadWritable, options?: any) {
        return ThreadsApiFp(this.configuration).threadsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsRead(id: string, options?: any) {
        return ThreadsApiFp(this.configuration).threadsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsSubscribed(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsSubscribed(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {string} [categories] 
     * @param {string} [starter] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsUnapproved(title?: string, categories?: string, starter?: string, page?: number, pageSize?: number, options?: any) {
        return ThreadsApiFp(this.configuration).threadsUnapproved(title, categories, starter, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ThreadWritable} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadsApi
     */
    public threadsUpdate(id: string, data: ThreadWritable, options?: any) {
        return ThreadsApiFp(this.configuration).threadsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


